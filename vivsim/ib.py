"""This file implements the immersed boundary method (IBM) in the lattice Boltzmann method framework.

The IB method is used to transfer the force between the fluid (discretized into a regular Eulerian lattice) 
and the object (represented by a set of Lagrangian markers). 
The markers can move freely in the lattice, meaning the markers and lattice are not aligned. 

Key variables:
- u: The velocity field of the fluid (distributed).
- u_marker(s): The interpolated velocity of the fluid at the marker(s).
- v: The velocity of the object (as a whole body).
- v_marker(s): The velocity of the object at marker(s).
- g: The force that the object applied to the fluid (distributed)
- g_marker(s): The force that the object applied to the fluid at marker(s).
- h: The force that the fluid applied to the object (as a whole body)
- h_marker(s): The force that the fluid applied to the object at marker(s)

"""

import jax.numpy as jnp
from . import lbm


# ----------------- Kernel functions -----------------


def kernel_range2(distance):
    """kernel function of range 2
    
    Args:
        distance (scalar or ndarray): The distance between the marker and the lattice.
    
    Returns:
        out (scalar or ndarray): The kernel function value. 
    """
    
    return jnp.where(jnp.abs(distance) <= 1, 1 - jnp.abs(distance), 0)


def kernel_range3(distance):
    """kernel function of range 3
    
    Args:
        distance (scalar or ndarray): The distance between the marker and the lattice.
    
    Returns:
        out (scalar or ndarray): The kernel function value. 
    """
    
    distance = jnp.abs(distance)
    return jnp.where(
        distance > 1.5,
        0,
        jnp.where(
            distance < 0.5,
            (1 + jnp.sqrt(1 - 3 * distance**2)) / 3,
            (5 - 3 * distance - jnp.sqrt(-2 + 6 * distance - 3 * distance**2)) / 6,
        ),
    )


def kernel_range4(distance):
    """kernel function of range 4
    
    Args:
        distance (scalar or ndarray): The distance between the marker and the lattice.
    
    Returns:
        out (scalar or ndarray): The kernel function value. 
    """
    
    distance = jnp.abs(distance)
    return jnp.where(
        distance > 2,
        0,
        jnp.where(
            distance < 1,
            (3 - 2 * distance + jnp.sqrt(1 + 4 * distance - 4 * distance ** 2)) / 8,
            (5 - 2 * distance - jnp.sqrt(- 7 + 12 * distance - 4 * distance ** 2)) / 8,
        ),
    )


def get_kernels(x_markers, y_markers, x_lattice, y_lattice, kernel_func):
    """Generate a stack of kernels for all the markers. The kernels are to be
    used in future interpolation and spreading operations.
    
    Args:
        x_markers, y_markers (ndarray of shape (N_MARKER)): The coordinates of markers.
        x_lattice, y_lattice (ndarray of shape (NX, NY)): The coordinates of the lattice.
        kernel_func (callable): The kernel function. Available options: 
            kernel_range2, kernel_range3, kernel_range4.
    
    Returns:
        out (ndarray of shape (N_MARKER, NX, NY))ï¼š The kernel function values.
    """
    return (kernel_func(x_lattice[None, ...] - x_markers[:, None, None]) \
          * kernel_func(y_lattice[None, ...] - y_markers[:, None, None]))


# ----------------- Core IB calculation -----------------


def interpolate_velocity_at_markers(u, kernels):
    """Interpolate the fluid velocity at all markers.
    
    Args:
        u (ndarray of shape (2, NX, NY)): The velocity field of fluid.
        kernels (ndarray of shape (N_MARKER, NX, NY)): A stack of kernel functions,
            pre-generated by get_kernels() to avoid repeated calculation.
    
    Returns:
        out (ndarray of shape (N_MARKER, 2)): The interpolated fluid velocity at markers.
    """
    
    return jnp.einsum("nxy,dxy->nd", kernels, u)


def get_noslip_forces_at_markers(v_markers, u_markers, marker_distance, rho=1):
    """Compute the needed forces required to enforce no-slip boundary at markers.
    according to g = 2 * rho * (v - u) / dt.
    
    Args:
        v_markers (ndarray of shape (N_MARKER, 2) or (2)): The velocity of the markers.
        u_markers (ndarray of shape (N_MARKER, 2)): The interpolated fluid velocity at the markers.
        rho (scaler or ndarray of shape (N_MARKER)): The density of the fluid.
    
    Returns:
        out (ndarray of shape (N_MARKER, 2)): The needed correction forces.
    """
    if v_markers.ndim == 1:
        return 2 * (v_markers[None,...] - u_markers)
       
    return 2 * (v_markers - u_markers) * rho * marker_distance


def spread_force_to_fluid(force_at_markers, kernels):
    """Spread the correction force that act only at the markers to the fluid.
    
    Args:
        force_at_markers (ndarray of shape (N_MARKER, 2)): The correction forces at markers.
        kernels (ndarray of shape (N_MARKER, NX, NY)): A stack of kernel functions,
            pre-generated by get_kernels() to avoid repeated calculation.
    
    Returns:
        out (ndarray of shape (2, NX, NY)): The force field applied to the fluid.
    """
    
    return jnp.einsum("nd,nxy->dxy", force_at_markers, kernels)


def multi_direct_forcing(rho, u, x_lattice, y_lattice, 
    v_markers, x_markers, y_markers, n_marker, marker_distance,
    n_iter, kernel_func):
    """Multi-direct forcing method to enforce no-slip boundary at markers.
    
    Args:
        rho (scalar or ndarray): The density of the fluid.
        u (ndarray of shape (2, NX, NY)): The velocity field of fluid.
        x_lattice, y_lattice (ndarray of shape (NX, NY)): The coordinates of the lattice.
        v_markers (ndarray of shape (2)): The velocity of the markers.
        x_markers, y_markers (ndarray of shape (N_MARKER)): The coordinates of markers.
        n_marker (int): The number of markers.
        marker_distance (scalar): The distance between two adjacent markers.
        n_iter (int): The number of iterations.
        kernel_func (callable): The kernel function. Available options: 
            kernel_range2, kernel_range3, kernel_range4.
    
    Returns:
        g (ndarray of shape (2, NX, NY)): The force field applied to the fluid.
        h_markers (ndarray of shape (N_MARKER, 2)): The forces applied to the markers.    
    """
        
    g = jnp.zeros_like(u)  # IB force to the fluid
    h_markers = jnp.zeros((n_marker, 2))  # IB force to the markers

    # calculate the kernel functions for all markers
    kernels = get_kernels(x_markers, y_markers, x_lattice, y_lattice, kernel_func)
    
    for _ in range(n_iter):
        
        # velocity interpolation
        u_markers = interpolate_velocity_at_markers(u, kernels)
        
        # compute correction force
        g_markers_correction = get_noslip_forces_at_markers(v_markers, u_markers, marker_distance, rho)
        g_correction = spread_force_to_fluid(g_markers_correction, kernels)
        
        # velocity correction
        u += lbm.get_velocity_correction(g_correction, rho)
        
        # accumulate the corresponding correction force to the markers and the fluid
        h_markers -= g_markers_correction
        g += g_correction
    
    return g, h_markers


# ----------------- Kinetics from Rigid Object to Markers -----------------


def get_markers_coords_2dof(x_markers_init, y_markers_init, d):
    """update the real-time position of the markers (without rotation)
    
    Args:
        x_markers_init, y_markers_init (ndarray of shape (N_MARKER)): The initial coordinates of the markers.
        d (ndarray of shape (1) or (3)): The instantaneous displacement of the object.
    
    Returns:
        x_markers, y_markers (ndarray of shape (N_MARKER)): The updated coordinates.
    """
    
    x_markers = x_markers_init + d[0]
    y_markers = y_markers_init + d[1]
    return x_markers, y_markers


def get_markers_coords_3dof(x_markers_init, y_markers_init, x_center_init, y_center_init, d):
    """update the real-time position of the markers (consider rotation)
    
    Args:
        x_markers_init, y_markers_init (ndarray of shape (N_MARKER)): The initial coordinates of the markers.
        x_center_init, y_center_init (scaler): The original coordinates of the object center.
        d (ndarray of shape (2)): The instantaneous displacement of the object.
    
    Returns:
        x_markers, y_markers (ndarray of shape (N_MARKER)): The updated coordinates.
    """
    x_rel = x_markers_init - x_center_init
    y_rel = y_markers_init - y_center_init
    x_markers = x_center_init + d[0] + x_rel * jnp.cos(d[2]) - y_rel * jnp.sin(d[2]) 
    y_markers = y_center_init + d[1] + x_rel * jnp.sin(d[2]) + y_rel * jnp.cos(d[2]) 
    
    return x_markers, y_markers


def get_markers_velocity_3dof(x_markers, y_markers, x_center_init, y_center_init, d, v):
    """Compute the velocity of the markers considering rotation.
    
    Args:
        x_markers, y_marker (ndarray of shape (N_MARKER)): instantaneous coordinates of the markers.
        x_center_init, y_center_init (scaler): The initial coordinates of the object center.
        d: The instantaneous displacement of the object with shape (dim).
        v: The instantaneous velocity of the object with shape (2).
    
    Returns:
        The velocity of the markers with shape (N_MARKER, 1).
    """
    x_rel = x_markers - x_center_init - d[0]
    y_rel = y_markers - y_center_init - d[1]
    
    v_markers = jnp.zeros((x_markers.shape[0], 2))
    v_markers = v_markers.at[:, 0].set(v[0] - v[2] * y_rel)
    v_markers = v_markers.at[:, 1].set(v[1] + v[2] * x_rel)
    return v_markers


# ----------------- Markers -> Rigid Object -----------------


def get_force_to_obj(force_at_markers):
    """Compute the total force to the object.
    
    Args:
        h_markers: The hydrodynamic force to the markers with shape (N_MARKER, 2).
        marker_distance: The distance between the markers.
    
    Returns:
        The total force to the object with shape (2).
    """
    
    return jnp.sum(force_at_markers, axis=0)


def get_torque_to_obj(x_markers, y_markers, x_center_init, y_center_init, d, force_at_markers):
    """Calculate the torque applied to the object.
    
    Args:
        x_markers, y_markers: The coordinates of the markers with shape (N_MARKER).
        x_center_init, y_center_init: The initial coordinates of the object center.
        h_markers: The distributed force to the fluid with shape (N_MARKER, 2).
        marker_distance: The distance between the markers.
    
    Returns:
        The torque (scalar).
    """
    
    x_rel = x_markers - (x_center_init + d[0])
    y_rel = y_markers - (y_center_init + d[1])
    
    return jnp.sum(x_rel * force_at_markers[:, 1] - y_rel * force_at_markers[:, 0])

